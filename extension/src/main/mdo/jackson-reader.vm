##*******************************************************************************
## Copyright (c) 2025 Guillaume Nodet
##
## This program and the accompanying materials are made available under
## the terms of the Eclipse Public License 2.0 which accompanies this
## distribution and is available at:
## https://www.eclipse.org/legal/epl-2.0/
##
## SPDX-License-Identifier: EPL-2.0
##******************************************************************************/
#
#if ( "${isMavenModel}" == "true" )
##
## The following loop code is required in order to change the type of the
## pomFile attribute to a java.nio.file.Path.  Modello does not support this
## type and loading a model with such a type would fail the Modello validation.
##
#foreach ( $field in $model.getClass("Model", $version).allFields )
  #if ( $field.name == "pomFile" )
    #set ( $dummy = $field.setType("java.nio.file.Path") )
  #end
#end
#set ( $locationTracking = true )
#end
#
#set ( $package = "${packageToolV4}" )
#set ( $className = "${model.name}JsonReader" )
#
#set ( $root = $model.getClass( $model.getRoot($version), $version ) )
#set ( $rootXml = $Helper.xmlClassMetadata( $root ) )
#set ( $rootTag = $rootXml.tagName )
#set ( $rootUcapName = $Helper.capitalise( $root.name ) )
#set ( $rootLcapName = $Helper.uncapitalise( $root.name ) )
#
#set ( $needXmlContext = false )
#foreach ( $class in $model.allClasses )
  #set ( $allFields = $Helper.xmlFields( $class ) )
  #foreach ( $field in $allFields )
    #if ( $Helper.xmlFieldMetadata( $field ).format )
      #set ( $needXmlContext = true )
    #end
  #end
#end
#
#MODELLO-VELOCITY#SAVE-OUTPUT-TO ${package.replace('.','/')}/${className}.java
// =================== DO NOT EDIT THIS FILE ====================
//  Generated by Modello Velocity from ${template}
//  template, any modifications will be overwritten.
// ==============================================================
package ${package};

import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.text.DateFormat;
#if ( $needXmlContext )
import java.util.ArrayDeque;
#end
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
#if ( $needXmlContext )
import java.util.Deque;
#end
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.apache.maven.api.annotations.Generated;
#if ( $locationTracking )
import ${packageModelV4}.InputSource;
import ${packageModelV4}.InputLocation;
#end
#foreach ( $class in $model.allClasses )
import ${packageModelV4}.${class.name};
#end
import org.apache.maven.internal.xml.XmlNodeStaxBuilder;
import org.apache.maven.api.xml.XmlNode;
import org.apache.maven.internal.xml.XmlNodeImpl;
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonLocation;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonToken;
import com.fasterxml.jackson.core.JsonParseException;

import static javax.xml.XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI;
import static javax.xml.XMLConstants.XML_NS_URI;
import static eu.maveniverse.maven.mason.JsonReaderHelper.*;

@Generated
@SuppressWarnings("deprecation")
public class ${className} {

    static class InputFactoryHolder {
        static final JsonFactory DEFAULT_JSON_FACTORY = new JsonFactory();
    }

    private final JsonFactory jsonFactory;
    private final ContentTransformer contentTransformer;

    public ${className}() {
        this(InputFactoryHolder.DEFAULT_JSON_FACTORY, (s, f) -> s);
    }

    public ${className}(JsonFactory jsonFactory) {
        this(jsonFactory, (s, f) -> s);
    }

    public ${className}(ContentTransformer contentTransformer) {
        this(InputFactoryHolder.DEFAULT_JSON_FACTORY, contentTransformer);
    }

    public ${className}(JsonFactory jsonFactory, ContentTransformer contentTransformer) {
        this.jsonFactory = jsonFactory;
        this.contentTransformer = contentTransformer;
    }

    /**
     * Returns the {@link JsonFactory} used by this reader.
     *
     * @return the {@link JsonFactory} used by this reader.
     */
    public JsonFactory getJsonFactory() {
        return jsonFactory;
    }

#if ( $locationTracking )
    private boolean addLocationInformation = true;

    /**
     * Returns the state of the "add location information" flag.
     *
     * @return boolean
     */
    public boolean getAddLocationInformation() {
        return addLocationInformation;
    } //-- boolean getAddLocationInformation()

    /**
     * Sets the state of the "add location information" flag.
     *
     * @param addLocationInformation a addLocationInformation object.
     */
    public void setAddLocationInformation(boolean addLocationInformation) {
        this.addLocationInformation = addLocationInformation;
    } //-- void setAddLocationInformation(boolean)
#end

    public ${root.name} read(Reader reader) throws IOException {
#if ( $locationTracking )
        return read(reader, true, null);
#else
        return read(reader, true);
#end
    }

    /**
     * @param reader a reader object.
     * @param strict a strict object.
     * @throws IOException if any.
     * @return ${root.name}
     */
#if ( $locationTracking )
    public ${root.name} read(Reader reader, boolean strict, InputSource inputSrc) throws IOException {
#else
    public ${root.name} read(Reader reader, boolean strict) throws IOException {
#end
        JsonFactory factory = getJsonFactory();
        JsonParser parser = factory.createParser(reader);
#if ( $locationTracking )
        return read(parser, strict, inputSrc);
#else
        return read(parser, strict);
#end
    } //-- ${root.name} read(Reader, boolean)

    public ${root.name} read(InputStream in) throws IOException {
#if ( $locationTracking )
        return read(in, true, null);
#else
        return read(in, true);
#end
    }

    /**
     * Method read.
     *
     * @param in a in object.
     * @param strict a strict object.
     * @throws IOException if any.
     * @return ${root.name}
     */
#if ( $locationTracking )
    public ${root.name} read(InputStream in, boolean strict, InputSource inputSrc) throws IOException {
#else
    public ${root.name} read(InputStream in, boolean strict) throws IOException {
#end
        JsonFactory factory = getJsonFactory();
        JsonParser parser = factory.createParser(in);
#if ( $locationTracking )
        return read(parser, strict, inputSrc);
#else
        return read(parser, strict);
#end
    } //-- ${root.name} read(InputStream, boolean)

    /**
     * Method read.
     *
     * @param parser a parser object.
     * @param strict a strict object.
     * @throws IOException if any.
     * @return ${root.name}
     */
#if ( $locationTracking )
    public ${root.name} read(JsonParser parser, boolean strict, InputSource inputSrc) throws IOException {
#else
    public ${root.name} read(JsonParser parser, boolean strict) throws IOException {
#end
#if ( $needXmlContext )
        Deque<Object> context = new ArrayDeque<>();
#end
        ${root.name} ${rootLcapName} = null;
        JsonToken token = parser.nextToken();
        if (token != JsonToken.START_OBJECT) {
            throw new IOException("Expected JSON object but found: " + token);
        }
#if ( $locationTracking )
        ${rootLcapName} = parse${rootUcapName}(parser, strict, inputSrc);
#elseif ( $needXmlContext )
        ${rootLcapName} = parse${rootUcapName}(parser, strict, context);
#else
        ${rootLcapName} = parse${rootUcapName}(parser, strict);
#end
        return ${rootLcapName};
    } //-- ${root.name} read(JsonParser, boolean)

#foreach ( $class in $model.allClasses )
 #if ( $class.name != "InputSource" && $class.name != "InputLocation" )
  #set ( $classUcapName = $Helper.capitalise( $class.name ) )
  #set ( $classLcapName = $Helper.uncapitalise( $class.name ) )
  #set ( $ancestors = $Helper.ancestors( $class ) )
  #set ( $allFields = $Helper.xmlFields( $class ) )
  #if ( $locationTracking )
    private ${classUcapName} parse${classUcapName}(JsonParser parser, boolean strict, InputSource inputSrc) throws IOException {
  #elseif ( $needXmlContext )
    private ${classUcapName} parse${classUcapName}(JsonParser parser, boolean strict, Deque<Object> context) throws IOException {
  #else
    private ${classUcapName} parse${classUcapName}(JsonParser parser, boolean strict) throws IOException {
  #end
        String tagName = parser.currentName();
        ${classUcapName}.Builder ${classLcapName} = ${classUcapName}.newBuilder(true);
#if ( $locationTracking )
        if (addLocationInformation) {
            ${classLcapName}.location("", new InputLocation(parser.currentLocation().getLineNr(), parser.currentLocation().getColumnNr(), inputSrc));
        }
#end
        JsonToken token = parser.currentToken();
        JsonLocation location = parser.currentLocation();
#if ( $class.name == "Dependency" )
        // Check if this is a simple string value instead of an object
        if (token.isScalarValue()) {
            // Handle the string format (id field)
            String[] gasvtco = parseGasvtcoString(parser.getText(), parser);
            ${classLcapName}.groupId(gasvtco[0]);
            ${classLcapName}.artifactId(gasvtco[1]);
            if (gasvtco[2] != null) {
                ${classLcapName}.scope(gasvtco[2]);
            }
            if (gasvtco[3] != null) {
                ${classLcapName}.version(gasvtco[3]);
            }
            if (gasvtco[4] != null) {
                ${classLcapName}.type(gasvtco[4]);
            }
            if (gasvtco[5] != null) {
                ${classLcapName}.classifier(gasvtco[5]);
            }
            if (gasvtco[6] != null) {
                ${classLcapName}.optional(gasvtco[6]);
            }
    #if ( $locationTracking )
            if (addLocationInformation) {
                InputLocation loc = new InputLocation(location.getLineNr(), location.getColumnNr(), inputSrc);
                ${classLcapName}.location("groupId", loc);
                ${classLcapName}.location("artifactId", loc);
                if (gasvtco[2] != null) {
                    ${classLcapName}.location("scope", loc);
                }
                if (gasvtco[3] != null) {
                    ${classLcapName}.location("version", loc);
                }
                if (gasvtco[4] != null) {
                    ${classLcapName}.location("type", loc);
                }
                if (gasvtco[5] != null) {
                    ${classLcapName}.location("classifier", loc);
                }
                if (gasvtco[6] != null) {
                    ${classLcapName}.location("optional", loc);
                }
            }
            return ${classLcapName}.build();
        }
    #end
#elseif ( $class.name == "Parent" || $class.name == "Extension" || $class.name == "Plugin" || $class.name == "ReportPlugin" )
        // Check if this is a simple string value instead of an object
        if (token.isScalarValue()) {
            // Handle the string format (id field)
            String[] gav = parseGavString(parser.getText(), parser);
            ${classLcapName}.groupId(gav[0]);
            ${classLcapName}.artifactId(gav[1]);
            if (gav[2] != null) {
                ${classLcapName}.version(gav[2]);
            }
    #if ( $locationTracking )
            if (addLocationInformation) {
                InputLocation loc = new InputLocation(location.getLineNr(), location.getColumnNr(), inputSrc);
                ${classLcapName}.location("groupId", loc);
                ${classLcapName}.location("artifactId", loc);
                if (gav[2] != null) {
                    ${classLcapName}.location("version", loc);
                }
            }
            return ${classLcapName}.build();
        }
    #end
#end

        // If not a compact form, expect and consume START_OBJECT
        if (token == JsonToken.START_OBJECT) {
            token = parser.nextToken();
            location = parser.currentLocation();
        }

        Set<String> parsed = new HashSet<>();
  #foreach ( $field in $allFields )
    #if ( $Helper.isFlatItems( $field ) )
        List<$field.to> ${field.name} = new ArrayList<>();
    #end
  #end
  #if ( $needXmlContext )
        context.addLast( ${classLcapName} );
  #end
        while (token == JsonToken.FIELD_NAME) {
            String childName = checkDuplicate(parser.currentName(), parser, parsed);
  #if ( $locationTracking )
            int line = addLocationInformation ? location.getLineNr() : -1;
            int column = addLocationInformation ? location.getColumnNr() : -1;
            Map<Object, InputLocation> locations = null;
            token = parser.nextToken();
  #end
            switch (childName) {
  #if ( $class.name == "Dependency" )
                case "id":
                    String[] gasvtco = parseGasvtcoString(nextValue(parser, strict), parser);
                    ${classLcapName}.groupId(gasvtco[0]);
                    ${classLcapName}.artifactId(gasvtco[1]);
                    if (gasvtco[2] != null) {
                        ${classLcapName}.scope(gasvtco[2]);
                    }
                    if (gasvtco[3] != null) {
                        ${classLcapName}.version(gasvtco[3]);
                    }
                    if (gasvtco[4] != null) {
                        ${classLcapName}.type(gasvtco[4]);
                    }
                    if (gasvtco[5] != null) {
                        ${classLcapName}.classifier(gasvtco[5]);
                    }
                    if (gasvtco[6] != null) {
                        ${classLcapName}.optional(gasvtco[6]);
                    }
    #if ( $locationTracking )
                    if (addLocationInformation) {
                        InputLocation loc = new InputLocation(line, column, inputSrc);
                        ${classLcapName}.location("groupId", loc);
                        ${classLcapName}.location("artifactId", loc);
                        if (gasvtco[2] != null) {
                            ${classLcapName}.location("scope", loc);
                        }
                        if (gasvtco[3] != null) {
                            ${classLcapName}.location("version", loc);
                        }
                        if (gasvtco[4] != null) {
                            ${classLcapName}.location("type", loc);
                        }
                        if (gasvtco[5] != null) {
                            ${classLcapName}.location("classifier", loc);
                        }
                        if (gasvtco[6] != null) {
                            ${classLcapName}.location("optional", loc);
                        }
                    }
    #end
                    break;
  #elseif ( $class.name == "Model" || $class.name == "Parent" || $class.name == "Extension" || $class.name == "Plugin" || $class.name == "ReportPlugin" )
                case "id":
                    String[] gav = parseGavString(nextValue(parser, strict), parser);
                    ${classLcapName}.groupId(gav[0]);
                    ${classLcapName}.artifactId(gav[1]);
                    if (gav[2] != null) {
                        ${classLcapName}.version(gav[2]);
                    }
    #if ( $locationTracking )
                    if (addLocationInformation) {
                        InputLocation loc = new InputLocation(line, column, inputSrc);
                        ${classLcapName}.location("groupId", loc);
                        ${classLcapName}.location("artifactId", loc);
                        if (gav[2] != null) {
                            ${classLcapName}.location("version", loc);
                        }
                    }
    #end
                    break;
  #end
  #set( $ift = "if" )
  #foreach ( $field in $allFields )
    #if ( ! $Helper.xmlFieldMetadata( $field ).transient && ! $Helper.xmlFieldMetadata( $field ).format )
      #set ( $fieldTagName = $Helper.xmlFieldMetadata( $field ).tagName )
      #if ( ! $fieldTagName )
        #set ( $fieldTagName = $field.name )
      #end
      #if ( $Helper.isFlatItems( $field ) )
        #set ( $fieldTagName = $Helper.singular( $fieldTagName ) )
      #end
      #set ( $fieldCapName = $Helper.capitalise($field.name))
                case "${fieldTagName}": {
      #if ( $field.type == "String" )
                    ${classLcapName}.${field.name}(interpolatedTrimmed(nextValue(parser, strict), "${fieldTagName}"));
                    break;
      #elseif ( $field.type == "boolean" || $field.type == "Boolean" )
                    ${classLcapName}.${field.name}(getBooleanValue(interpolatedTrimmed(nextValue(parser, strict), "${fieldTagName}"), "${fieldTagName}", parser, ${field.defaultValue}));
                    break;
      #elseif ( $field.type == "int" || $field.type == "Integer" )
                    ${classLcapName}.${field.name}(getIntegerValue(interpolatedTrimmed(nextValue(parser, strict), "${fieldTagName}"), "${fieldTagName}", parser, strict, ${field.defaultValue}));
                    break;
      #elseif ( $field.type == "DOM" )
        #if ( $locationTracking )
                    ${classLcapName}.${field.name}(buildXmlNode(parser, inputSrc, addLocationInformation));
        #else
                    ${classLcapName}.${field.name}(buildXmlNode(parser));
        #end
                    break;
      #elseif ( $field.type == "java.util.List" && $field.to == "String" && $field.multiplicity == "*" )
                    List<String> ${field.name} = new ArrayList<>();
        #if ( $locationTracking )
                    locations = new HashMap<>();
        #end
                    if (token != JsonToken.START_ARRAY) {
                        throw new IOException("Expected JSON array but found: " + token + " at line " + parser.currentLocation().getLineNr() + ", column " + parser.currentLocation().getColumnNr());
                    }
                    while ((token = parser.nextToken()) != JsonToken.END_ARRAY) {
                        if (token == JsonToken.VALUE_STRING) {
        #if ( $locationTracking )
                            if (addLocationInformation) {
                                locations.put(Integer.valueOf(locations.size()), 
                                    new InputLocation(parser.currentLocation().getLineNr(),
                                                    parser.currentLocation().getColumnNr(), 
                                                    inputSrc));
                            }
        #end
                            ${field.name}.add(interpolatedTrimmed(parser.getText(), "${fieldTagName}"));
                        } else {
                            throw new IOException("Expected string value in array but found: " + token);
                        }
                    }
                    ${classLcapName}.${field.name}(${field.name});
                    break;
      #elseif ( $field.type == "java.util.Properties" && $field.to == "String" && $field.multiplicity == "*" )
                    Map<String, String> ${field.name} = new LinkedHashMap<>();
        #if ( $locationTracking )
                    locations = new HashMap<>();
        #end
                    if (token != JsonToken.START_OBJECT) {
                        throw new IOException("Expected START_OBJECT but found: " + token + " at line " + parser.currentLocation().getLineNr() + ", column " + parser.currentLocation().getColumnNr());
                    }
                    while (parser.nextToken() == JsonToken.FIELD_NAME) {
                        String key = parser.currentName();
                        token = parser.nextToken();
                        String value = nextValue(parser, strict).trim();
        #if ( $locationTracking )
                        if (addLocationInformation) {
                            locations.put(key, new InputLocation(parser.currentLocation().getLineNr(), parser.currentLocation().getColumnNr(), inputSrc));
                        }
        #end
                        ${field.name}.put(key, value);
                    }
                    ${classLcapName}.${field.name}(${field.name});
                    break;
      #elseif ( $field.to && $field.multiplicity == "1" )
        #if ( $locationTracking )
                    ${classLcapName}.${field.name}(parse${field.toClass.name}(parser, strict, inputSrc));
        #elseif ( $needXmlContext )
                    ${classLcapName}.${field.name}(parse${field.toClass.name}(parser, strict, context));
        #else
                    ${classLcapName}.${field.name}(parse${field.toClass.name}(parser, strict));
        #end
                    break;
      #elseif ( $field.to && $field.multiplicity == "*" && $Helper.isFlatItems( $field ) )
        #if ( $locationTracking )
                    ${field.name}.add(parse${field.toClass.name}(parser, strict, inputSrc));
        #elseif ( $needXmlContext )
                    ${field.name}.add(parse${field.toClass.name}(parser, strict, context));
        #else
                    ${field.name}.add(parse${field.toClass.name}(parser, strict));
        #end
                    break;
      #elseif ( $field.to && $field.multiplicity == "*" )
                    List<$field.to> ${field.name} = new ArrayList<>();
                    if (token != JsonToken.START_ARRAY) {
                        throw new IOException("Expected JSON array but found: " + token + " at line " + parser.currentLocation().getLineNr() + ", column " + parser.currentLocation().getColumnNr());
                    }
                    while ((token = parser.nextToken()) != JsonToken.END_ARRAY) {
        #if ( $locationTracking )
                        ${field.name}.add(parse${field.toClass.name}(parser, strict, inputSrc));
        #elseif ( $needXmlContext )
                        ${field.name}.add(parse${field.toClass.name}(parser, strict, context));
        #else
                        ${field.name}.add(parse${field.toClass.name}(parser, strict));
        #end
                    }
                    ${classLcapName}.${field.name}(${field.name});
                    break;
      #else
                    // TODO: type=${field.type} to=${field.to} multiplicity=${field.multiplicity}
                    break;
      #end
                }
      #set( $ift = "else if" )
    #end
  #end
                default: {
                    checkUnknownElement(parser, strict);
                    break;
                }
            }
  #if ( $locationTracking )
            if (addLocationInformation) {
                ${classLcapName}.location(childName, new InputLocation(line, column, inputSrc, locations));
            }
  #end
            token = parser.nextToken();
        }
  #if ( $needXmlContext )
        context.removeLast();
  #end
  #foreach ( $field in $allFields )
    #if ( $Helper.isFlatItems( $field ) )
        ${classLcapName}.${field.name}(${field.name});
    #end
  #end
  #foreach ( $field in $allFields )
    #if ( $Helper.xmlFieldMetadata( $field ).format )
        ${classLcapName}.${field.name}($Helper.xmlFieldMetadata( $field ).format);
    #end
  #end
        return ${classLcapName}.build();
    }

 #end
#end

    private String checkDuplicate(String tagName, JsonParser parser, Set<String> parsed) throws IOException {
#set( $aliases = { } )
#set( $flats = { } )
#foreach( $class in $model.allClasses )
  #foreach ( $field in $class.getFields($version) )
    #set ( $fieldTagName = $Helper.xmlFieldMetadata( $field ).tagName )
    #if ( ! $fieldTagName )
      #set ( $fieldTagName = $field.name )
    #end
    #if ( $field.alias )
      #set ( $dummy = $aliases.put( $field.alias, $fieldTagName ) )
    #end
    #if ( $Helper.isFlatItems( $field ) )
      #set ( $fieldTagName = $Helper.singular($fieldTagName) )
      #set ( $dummy = $flats.put( $fieldTagName, "" ) )
    #end
  #end
#end
#if ( ! ${aliases.isEmpty()} )
        switch (tagName) {
  #foreach( $entry in $aliases.entrySet() )
        case "${entry.key}":
            tagName = "${entry.value}";
            break;
  #end
        }
#end
#if ( ! ${flats.isEmpty()} )
        switch (tagName) {
  #foreach( $entry in $flats.entrySet() )
        case "${entry.key}":
  #end
            break;
        default:
            if (!parsed.add(tagName)) {
                throw new IOException("Duplicated tag: '" + tagName + "'");
            }
        }
#else
        if (!parsed.add(tagName)) {
            throw new IOException("Duplicated tag: '" + tagName + "'");
        }
#end
        return tagName;
    }

    /**
     * Method checkUnknownElement.
     *
     * @param parser a parser object.
     * @param strict a strict object.
     * @throws IOException if any.
     */
    private void checkUnknownElement(JsonParser parser, boolean strict) throws IOException {
        if (strict) {
            throw new IOException("Unrecognised tag: '" + parser.currentName() + "'");
        }

        // Skip the current object and any nested content
        int depth = 1; // Start at 1 since we're already inside an object
        while (depth > 0) {
            JsonToken token = parser.nextToken();
            if (token == JsonToken.START_OBJECT) {
                depth++;
            } else if (token == JsonToken.END_OBJECT) {
                depth--;
            }
        }
    } //-- void checkUnknownElement(JsonParser, boolean)

    /**
     * Method getTrimmedValue.
     *
     * @param s a s object.
     * @return String
     */
    private String getTrimmedValue(String s) {
        if (s != null) {
            s = s.trim();
        }
        return s;
    } //-- String getTrimmedValue(String)

    /**
     * Method interpolatedTrimmed.
     *
     * @param value a value object.
     * @param context a context object.
     * @return String
     */
    private String interpolatedTrimmed(String value, String context) {
        return getTrimmedValue(contentTransformer.transform(value, context));
    } //-- String interpolatedTrimmed(String, String)

    private String nextValue(JsonParser parser, boolean strict) throws IOException {
        JsonToken token = parser.currentToken();
        if (token.isScalarValue()) {
            return parser.getText();
        }
        throw new IOException("Expected scalar value but found " + token + " at line " + parser.currentLocation().getLineNr() + ", column " + parser.currentLocation().getColumnNr());
    }

    public static interface ContentTransformer {
        /**
         * Interpolate the value read from the xpp3 document
         * @param inputSrc The input source value
         * @param fieldName A description of the field being interpolated. The implementation may use this to
         *                           log stuff.
         * @return The interpolated value.
         */
        String transform(String inputSrc, String fieldName);
    }

}
